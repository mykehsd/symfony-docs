Practical Symfony: Day 6
########################

## More with the Model
Yesterday was a great day. You learned how to create pretty URLs and how to use the Symfony2 framework to automate a lot of things for you.

Today, we will enhance the Jobeet website by tweaking the code here and there. In the process, you will learn more about all the features we have introduced during the first five days of this tutorial.

### Lifecycle Callbacks
Sometimes, you need to perform an action right before or after an entity is inserted, updated, or deleted. These types of actions are known as "lifecycle" callbacks, as they're callback methods that you need to execute during different stages of the lifecycle of an entity (e.g. the entity is inserted, updated, deleted, etc).

It would be helpful to identify when a job was created as well as knowing when the job was last updated.  For this lets create 2 new columns in our database called created_at and updated_at. First we need to tell Doctrine that our entity has lifecycle callbacks in our annotations:
```
// src/Jobeet/JobBundle/Entity/Job.php
/**
 * Jobeet\JobBundle\Entity\Job
 *
 * @ORM\Table()
 * @ORM\Entity
 * @ORM\HasLifecycleCallbacks()
 */
class Job
...
```

Now lets create our 2 new columns and the methods to update them:
```
    /**
     * @var timestamp $created_at
     *
     * @ORM\Column(name="created_at", type="datetime", nullable=false)
     */
    private $created_at;

    /**
     * @var timestamp $updated_at
     *
     * @ORM\Column(name="updated_at", type="datetime", nullable=false)
     */
    private $updated_at;

    /**
     * @ORM\PrePersist
     */
    public function setCreatedAtValue()
    {
        $this->created_at = new \DateTime();
    }

    /**
     * @ORM\PreUpdate
     * @ORM\PrePersist
     */
    public function setUpdateAtValue()
    {
        $this->updated_at = new \DateTime();
    }

```

Note that our created_at field only has the PrePersist callback, while updated_at has PreUpdate and PrePersist.  We want to update the updated_at column value everytime the entity is updated, while our create_at column is only updated on creation.

Lets rebuild our database and load the fixtures again
```
php app/console doctrine:schema:update --force
php app/console doctrine:fixtures:load
```


### The Doctrine Query Object
From day 2 requirements:

"When a user comes to the Jobeet website, she sees a list of active jobs."

But as of now, all jobs are displayed, whether they are active or not:

```
# src/Jobeet/JobBundle/Controller/JobController.php
    public function indexAction()
    {
        $em = $this->getDoctrine()->getManager();

        $entities = $em->getRepository('JobeetJobBundle:Job')->findAll();

...
```

An active job is one that was posted less than 30 days ago. The findAll() method will make a request to the database but not specify any where condition which means that all the records are retrieved from the database.

Let's change it to only select active jobs:
```
# src/Jobeet/JobBundle/Controller/JobController.php
    public function indexAction()
    {
        $em = $this->getDoctrine()->getManager();

        $repository = $em->getRepository('JobeetJobBundle:Job');
        $query = $repository->createQueryBuilder('j')
            ->where('j.created_at > ?', date('Y-m-d H:i:s', time() - 86400 * 30)); 

        $entities = $query->getResult();

...
```

### Debugging Doctrine generated SQL
As you don't write the SQL statements by hand, Doctrine will take care of the differences between database engines and will generate SQL statements optimized for the database engine you choose during day 3. But sometimes, it is of great help to see the SQL generated by Doctrine; for instance, to debug a query that does not work as expected. In the dev environment, Symfony2 logs these queries (along with much more) in the app/logs/ directory. There is one log file for every environment. The file we are looking for is named dev.log:
```
[] doctrine.DEBUG: SELECT j0_.id AS id0, j0_.type AS type1, j0_.company AS company2, j0_.logo AS logo3, j0_.url AS url4, j0_.position AS position5, j0_.location AS location6, j0_.description AS description7, j0_.how_to_apply AS how_to_apply8, j0_.token AS token9, j0_.is_public AS is_public10, j0_.is_activated AS is_activated11, j0_.email AS email12, j0_.expires_at AS expires_at13, j0_.created_at AS created_at14, j0_.updated_at AS updated_at15, j0_.category_id AS category_id16 FROM Job j0_ WHERE j0_.created_at > ? ["2012-09-15 16:13:21"] []
```

You can see for yourself that Doctrine has a where clause for the created_at column (WHERE j.created_at > ?).

This is good, but it's a bit annoying to have to switch between the browser, the IDE, and the log file every time you need to test a change. Thanks to the Symfony2 web debug toolbar, all the information you need is also available within the comfort of your browser:

# INSERT IMAGE HERE #


### Object Serialization
Even if the above code works, it is far from perfect as it does not take into account some requirements from day 2:

"A user can come back to re-activate or extend the validity of the job ad for an extra 30 days..."

But as the above code only relies on the created_at value, and because this column stores the creation date, we cannot satisfy the above requirement.

But if you remember the database schema we have described during day 3, we also have defined an expires_at column. Currently this value is always empty as it is not set in the fixture data. But when a job is created, it can be automatically set to 30 days after the current date.

When you need to do something automatically before a Doctrine object is serialized to the database, you can define a lifecycle callback
```
// src/Jobeet/JobBundle/Entity/Job.php
    /**
     * @ORM\PrePersist
     */
    public function setExpiresAtValue()
    {
        if ($this->expires_at === null) {
            $expires = new \DateTime();
            $expires->add(new \DateInterval('P30D'));
            $this->expires_at = $expires;
        }
        return $this;
    }
```

Now, let's change the action to use the expires_at column instead of the created_at one to select the active jobs:

```
# src/Jobeet/JobBundle/Controller/JobController.php

        $query = $repository->createQueryBuilder('j')
                ->where('j.expires_at > :expires')
                ->setParameter('expires', new \DateTime() )
                ->getQuery();
```
We restrict the query to only select jobs with the expires_at date in the future.

### More with Fixtures
Refreshing the Jobeet homepage in your browser won't change anything as the jobs in the database have been posted just a few days ago. Let's change the fixtures to add a job that is already expired:

```
// src/Jobeet/JobBundle/DataFixtures/ORM/LoadJobData.php
        $job_expired = new Job();
        $job_expired->setCategory( $manager->merge($this->getReference('category-programming')));
        $job_expired
            ->setType('full-time')
            ->setCompany('Sensio Labs')
            ->setLogo('sensio-labs.gif')
            ->setUrl('http://www.sensiolabs.com/')
            ->setPosition('Web Designer')
            ->setLocation('Paris, France')
            ->setDescription('Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolorin reprehenderit in')
            ->setHowToApply('Send your resume to fabien.potencier [at] sensio.com')
            ->setIsPublic(true)
            ->setIsActivated(true)
            ->setToken('job_expired')
            ->setEmail('job@example.com')
            ->setExpiresAt( new \DateTime('2010-10-10'));
        $manager->persist($job_expired);
        $this->addReference('job_expired', $job_expired);
```

### Services
A modern PHP application is full of objects. One object may facilitate the delivery of email messages while another may allow you to persist information into a database.  In our jobeet application one object may create new jobs while another may deliver notifications to users about new posts. 

Up until now, we have communicated with our Entity class directly from our controller.  What happens when we want to create an API or allow another bundle to create/update/delete our Entity objects?  What if we wanted to migrate away from Doctrine?  Symfony2 is about decoupling components of our application, so why not abstract how our application interacts with our Entities?  For more information on (Symfony2 Services)[http://symfony.com/doc/current/book/service_container.html] read the documentation.  

#### Job Manager
The first place we can decouple our Entities from Controllers is by creating a Job Manager that handles all of the interaction of our objects and actions.  Lets create our service first:
``` 
// src/Jobeet/JobBundle/Model/JobManager.php
<?php
namespace Jobeet\JobBundle\Model;

class JobManager
{
    // Our entity manager
    private $em;

    /** 
     * __construct
     * @param (object) entityManager 
     * @return null
     */
    public function __construct( $entityManager )
    {
        $this->em = $entityManager;
    }

    /** 
     * getActiveJobs
     * @return (array) Enttiy\Job
     */
    public function getActiveJobs()
    {
        $repository = $this->em->getRepository('JobeetJobBundle:Job');
            $query = $repository->createQueryBuilder('j')
                    ->where('j.expires_at > :expires')
                    ->setParameter('expires', new \DateTime() )
                    ->getQuery();
        return $query->getResult();
    }
}
```

Now define our service and make it available to Symfony2 
```
// src/Jobeet/JobBundle/Resources/config/services.yml
parameters:
  jobeet_job.jobManager.class: Jobeet\JobBundle\Model\JobManager

services:
  jobeet_job.job_manager:
    class: %jobeet_job.jobManager.class%
    arguments: [ @doctrine.orm.entity_manager ]
```

And now tell our application to load our bundle service.yml file, add the following into the imports section
```
// app/config/config.yml
imports
    ....
    - { resource: @JobeetJobBundle/Resources/config/services.yml }
    ....
```

Services sometimes need to interact with each other, but we need to be sure not to hardcode any class names or variables into our code so that they can be customized later.  We know that our JobManager will be interacting with Doctrine, so we can inject it into our __construct method as an argument.  "arguments: [ @doctrine.orm.entity_manager ]" tells Symfony2 just that when compiling our new JobManager service.

### Custom Configuration
In the JobeetBundle\Entity\Job::setExpiresAtValue method, we have hardcoded the number of days for the job to expire. It would have been better to make the 30 days configurable and customizable by the application.

By default Symfony2 will look for our application configuration under the namespace of 'jobeet_job'.  We just need to expose the configuration setting to our bundle by editing our Configuration class in DI. To create a new setting 'active_days', make the following addition:
```
// src/Jobeet/JobBundle/DependencyInjection/Configuration.php
    public function getConfigTreeBuilder()
    {
        $treeBuilder = new TreeBuilder();
        $rootNode = $treeBuilder->root('jobeet_job');

        $rootNode
            ->children()
            ->scalarNode('active_days')->defaultValue('30')->end()
            ->end();

        return $treeBuilder;
    }
```

Now in our JobeetJobExtension::load method, take our configuration value and set it in our JobManager
```
  $container->setParameter('jobeet_job.default_active_days', $config['active_days']);
```

Now that we have our parameter validated and set, we can inject it into our JobManager service.  We will add a second argument to the constructor that will contain the value of our configuration value.
```
// src/Jobeet/JobBundle/Resources/config/services.yml
services:
  jobeet_job.job_manager:
    class: %jobeet_job.jobManager.class%
    arguments: [ @doctrine.orm.entity_manager, %jobeet_job.default_active_days% ]
```

Add our variable into the JobManager constructor:
```
    private $active_days;
    public function __construct( $entityManager, $active_days )
    {
        $this->em = $entityManager;
        $this->active_days = (int) $active_days;
    }
```

By default our active_days value with be "30", but if we wanted to change that we just override it in our config.yml
```
/// app/config/config.yml
jobeet_job:
  active_days: 100
```

### Categories on the Homepage
From day 2 requirements:
"The jobs are sorted by category and then by publication date (newer jobs first)."

Until now, we have not taken the job category into account. From the requirements, the homepage must display jobs by category. First, we need to get all categories with at least one active job.
Open the JobManager class and add a getCategoriesWithJobs method:
```
// src/Jobeet/JobBundle/Model/JobManager.php
    /**
     * getCategoriesWithJobs
     * Returns all categories with at least 1 active job
     * @return (array) JobeetJobbundle:Category
     */
    public function getCategoriesWithJobs()
    {
        $repository = $this->em->getRepository('JobeetJobBundle:Category');
        $query = $repository->createQueryBuilder('c')
            ->leftJoin('c.jobs', 'j')
            ->where('j.expires_at > :expires')
            ->setParameter('expires', new \DateTime() )
            ->getQuery();
        return $query->getResult();
    }

```

In the example of our homepage, we may want our getActiveJobs method to optionally filter the collection of jobs by a category.  We can easily do that by modifying our method:
```
// src/Jobeet/JobBundle/Model/JobManager.php

    public function getActiveJobs( Category $category = null, $limit = null )
    {
        $repository = $this->em->getRepository('JobeetJobBundle:Job');
            $qb =$repository->createQueryBuilder('j');
            $qb->where('j.expires_at > :expires')
                    ->setParameter('expires', new \DateTime() );

            if (null !== $category) {
                $qb->andWhere('j.category = :id')
                    ->setParameter('id', $category->getId() );
            }

            if (null !== $limit) {
                $qb->setMaxResults($limit);
            }

            return $qb->getQuery()->getResult();
        
    }
```

Change the index action accordingly
```
        $categories = array();
        foreach ($this->get('jobeet_job.job_manager')->getCategoriesWithJobs() as $category)
        {
            $categories[] = array (
                'name' => $category->getName(),
                'active_jobs' => $this->get('jobeet_job.job_manager')->getActiveJobs ( $category )
            );
        }

        return $this->render('JobeetJobBundle:Job:index.html.twig', array(
            'categories' => $categories
        ));
```

Previously we setup the Job -> Category relationship in our Job entity, however we didn't do the inverse.  We want to be able to retrieve jobs from a specific category, so lets setup the relationship
```
// src/Jobeet/JobBundle/Entity/Category.php

    /**
     * @ORM\OneToMany(targetEntity="Job", mappedBy="category")
     */
    private $jobs;

    public function __construct()
    {
        $this->jobs = new ArrayCollection();
    }

    /**
     * getJobs
     * @return array
     */
    public function getJobs()
    {
        return $this->jobs;
    }
```

Finally, lets modify our Twig template to loop through the categories and display jobs
```
// src/Jobeet/JobBundle/Resources/views/Job/index.html.twig
{% for category in categories %}
<h2>{{ category.name }}</h2>
    {% for entity in category.active_jobs %}
<table class="records_list table table-striped table-bordered table-hover">
    <tbody>
        <tr>
            <td>{{ entity.location }}</td>
            <td>{{ entity.position }}</td>
            <td><a href="{{ path('job_show', { 'company': entity.company, 'position': entity.position, 'location': entity.location, 'id': entity.id }) }}">{{ entity.company }}</a></td>
        </tr>
    {% endfor %}
    </tbody>
</table>
{% endfor %}
```

### Limit the Results

There is still one requirement to implement for the homepage job list:

"For each category, the list only shows the first 10 jobs and a link allows to list all the jobs for a given category."

Lets create our bundle configuration parameter, much like we did for our active_days parameter.
```
// src/Jobeet/JobBundle/DependancyInjection/Configuration.php
        $rootNode
            ->children()
            ->scalarNode('active_days')->defaultValue('30')->end()
            ->scalarNode('max_jobs_on_homepage')->defaultValue(10)->end()
            ->end();
```

Set the configuration parameter in our container
```
// src/Jobeet/JobBundle/DependancyInjection/JobeetJobExtension.php
        $container->setParameter('jobeet_job.max_jobs_on_homepage', $config['max_jobs_on_homepage']);
```

We have already modified our getActiveJobs method to accept an optional limit value, so now we just need to pass that value in our controller
```
# src/Jobeet/JobBundle/Controller/JobController.php
            $categories[] = array (
                'name' => $category->getName(),
                'active_jobs' => $this->get('jobeet_job.job_manager')->getActiveJobs ( $category, $this->container->getParameter('jobeet_job.max_jobs_on_homepage') )
            );
```


### Dynamic Fixtures

Unless you lower the max_jobs_on_homepage setting to one, you won't see any difference. We need to add a bunch of jobs to the fixture. So, you can copy and paste an existing job ten or twenty times by hand... but there's a better way. Duplication is bad, even in fixture files. Lets create a loop in our LoadJobData class to create 30 jobs in our programming category
```

        for ($i = 100; $i<=130; $i++)
        {
            $company = new Job();
            $company->setCategory( $manager->merge($this->getReference('category-programming')));
            $company
                ->setType('full-time')
                ->setCompany('Company ' . $i)
                ->setLogo('sensio-labs.gif')
                ->setUrl('http://www.sensiolabs.com/')
                ->setPosition('Web Developer')
                ->setLocation('Paris, France')
                ->setDescription('You\'ve already developed websites with Symfony2 and you want to work with Open-Source technologies. You have a minimum of 3 years experience in web development with PHP or Java and you wish to participate to development of Web 2.0 sites using the best frameworks available.')
                ->setHowToApply('Send your resume to fabien.potencier [at] sensio' . $i . '.com')
                ->setIsPublic(true)
                ->setIsActivated(true)
                ->setToken('company_' . $i)
                ->setEmail('job@example.com')
                ->setExpiresAt ($default_expires_at);

            $manager->persist($company);
            $this->addReference('company_'. $i, $company);
        }
```

You can now reload the fixtures with the doctrine:fixtures:load task and see if only 10 jobs are displayed on the homepage for the Programming category. 

### Secure the Job Page

When a job expires, even if you know the URL, it must not be possible to access it anymore. Try the URL for the expired job (replace the id with the actual id in your database - SELECT id, token FROM job WHERE expires_at < NOW()):
```
/job/Extreme%20Sensio/Paris,%20France/ID/Web%20Designer/show
```

Instead of displaying the job, we need to forward the user to a 404 page. 
First change our controller call to a method that only returns active jobs:
```
    public function showAction($company, $location, $id, $position)
    {
        $entity = $this->get('jobeet_job.job_manager')->findActiveJob($id);
```

And add this method in our job manager
```
	/**
	 * findActiveJob
	 * @param (int) PK of Job Entity
	 * @return Entity\Job
	 */
	public function findActiveJob( $id )
	{        
		$qb = $this->em->getRepository('JobeetJobBundle:Job')->createQueryBuilder('j');
		$qb->where('j.expires_at > :expires')
			->andWhere('j.id = :id')
			->setParameters( array( 'id' => $id, 'expires' => new \DateTime()));

    	try {
    		$qb->getQuery()->getSingleResult();
    	} catch (\Doctrine\Orm\NoResultException $e) {
    		return false;
    	}
    }
```

Normally our getSingleResult call would return a NoResultException when no rows were returned.  That would send a 503 (system error) status to the client's browser, however it should be a 404 (not found).  In this case lets catch the exception and return false so our controller can create NotFoundHttpException instead.

### Link to the Category Page

Now, let's add a link to the category page on the homepage and create the category page.

But, wait a minute. the hour is not yet over and we haven't worked that much. So, you have plenty of free time and enough knowledge to implement this all by yourself! Let's make an exercise of it. Check back tomorrow for our implementation.








